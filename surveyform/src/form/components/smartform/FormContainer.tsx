import React from "react";
import gql from "graphql-tag";
import type { DocumentNode } from "graphql";

import { Form, getFormFragments } from "@devographics/react-form";
import { VulcanGraphqlModel, getFragmentName } from "@vulcanjs/graphql";
// TODO: replace by direct calls to CRUD operations for a response
import { buildSingleQuery } from "@devographics/crud";
import { VulcanUser } from "@vulcanjs/permissions";
// Be careful to import from the Consumer!
import {
  PassedDownFormProps,
  useVulcanCurrentUser,
} from "@devographics/react-form";
import { Loading } from "~/core/components/ui/Loading";
import useSWR from "swr";
import { graphqlFetcher } from "~/core/utils/graphqlQuery";

export interface FormContainerProps extends PassedDownFormProps {
  model: VulcanGraphqlModel;
  /** Document id for edition mode, will automatically fetch the document */
  documentId?: string;
  /** Slug (= human readable unique id) for edition mode, will automatically fetch the document */
  slug?: string;
  /**
   * List only those fields in the form
   */
  fields?: Array<string>;
  /**
   * List default fields + those additional fields as well
   */
  addFields?: Array<string>;
  /**
   * Force a currentUser, overriding the currentUser obtained
   * via Context
   *
   * If you use many forms in your app,
   * it might be better to set VulcanCurrentUserContext
   * at the top-level of your app
   * (eg in "pages/_app.js" for Next.js)
   */
  currentUser?: VulcanUser | null;
  loadingCurrentUser?: boolean;
}
export type SmartFormProps = FormContainerProps;

const useFragments = (
  props: Pick<
    FormContainerProps,
    | "queryFragment"
    | "queryFragmentName"
    // for auto generation
    | "model"
    | "fields"
    | "addFields"
  >,
  formType: "edit" | "new"
) => {
  // get fragment used to decide what data to load from the server to populate the form,
  // as well as what data to ask for as return value for the mutation
  // TODO: move out of the component
  //const getFragments = () => {
  let queryFragment: DocumentNode | undefined;
  let queryFragmentName: string | undefined;

  // if queryFragment or mutationFragment props are specified, accept either fragment object or fragment string
  // TODO: not sure we actually need that, gApollo accepts fragments or string normally
  if (props.queryFragment) {
    if (typeof props.queryFragment === "string") {
      queryFragment = gql`
        ${props.queryFragment}
      `;
      if (!props.queryFragmentName)
        throw new Error(
          "When using a string queryFragment, queryFragmentName is mandatory"
        );
      queryFragmentName = props.queryFragmentName;
    } else {
      // DocumentNode
      queryFragment = props.queryFragment;
      // automatically compute the fragment name
      queryFragmentName =
        props.queryFragmentName || getFragmentName(props.queryFragment);
    }
  }
  // auto generate fragments
  let autoFormFragments;
  if (!props.queryFragment) {
    const { model, fields, addFields } = props;
    // autogenerated fragments
    autoFormFragments = getFormFragments({
      formType,
      model,
      fields,
      addFields,
    });
  }
  // use autogenerated value if necessary
  if (!props.queryFragment) {
    queryFragment = autoFormFragments.queryFragment;
    queryFragmentName = autoFormFragments.queryFragmentName;
  }
  return {
    queryFragment: queryFragment as DocumentNode,
    queryFragmentName: queryFragmentName as string,
  };
};

const useFormDocument = (
  formType: string,
  query: DocumentNode,
  variables: any
) => {
  const skip = formType === "new";
  console.log("Calling useFormDocument", { skip, variables });
  const rawRes = useSWR<any>(skip ? null : [query, variables], graphqlFetcher);
  if (rawRes.error) {
    console.error("Error while fetching form document", rawRes.error);
  }
  return {
    ...rawRes,
    document: rawRes.data?.response,
    loading: !rawRes.error && !rawRes.data,
    // TODO: not sure if we strictly need refetching
    // it's hard to implement with SWR and GraphQL, wait for moving to REST
    refetch: () => {
      console.warn("Refetch not yet implemented with SWR + GraphQL");
    },
  };
};

export const FormContainer = (props: FormContainerProps) => {
  return (
    // TODO: add VulcanComponents here
    <FormContainerInner {...props} />
  );
};
// Fonctionnal version to be able to use hooks
const FormContainerInner = (props: FormContainerProps) => {
  const {
    model,
    documentId,
    slug,
    currentUser: currentUserFromProps,
    loadingCurrentUser: loadingCurrentUserFromProps,
  } = props;
  const { schema } = model;
  // if a document is being passed, this is an edit form
  const isEdit = documentId || slug;
  const formType = isEdit ? "edit" : "new";

  const childProps = {
    formType,
    schema,
  };

  const { queryFragment, queryFragmentName } = useFragments(props, formType);

  const queryOptions: any /*UseSingleOptions<any>*/ = {
    model,
    // TODO: what this option does?
    // queryName: `${prefix}FormQuery`,
    fragment: queryFragment,
    fragmentName: queryFragmentName,
    // fragmentName?
    input: {
      id: documentId,
      enableCache: false,
      // TODO: support slug
    },
    queryOptions: {
      // we always want to load a fresh copy of the document
      fetchPolicy: "network-only" as const,
      pollInterval: 0, // no polling, only load data once
      skip: formType === "new",
    },
  };
  console.log("useSingle queryOptions", queryOptions);
  // TODO: finish the "get-section" endpoint to turn into a REST endpoint
  // instead of using graphql
  const query = buildSingleQuery({
    model,
    fragment: queryFragment,
    fragmentName: queryFragmentName,
  });
  const { data, document, loading, refetch } = useFormDocument(
    formType,
    query,
    {
      input: {
        id: documentId,
        enableCache: false,
      },
    }
  );
  console.log("FORM DATA", data, document);
  // const { data, document, loading, refetch } = useSingle(queryOptions);
  if (formType !== "new") {
    console.debug(
      "useSingle result",
      "data",
      data,
      "document",
      document,
      "loading",
      loading
    );
  } else {
    console.debug("new");
  }

  const {
    currentUser: currentUserFromContext,
    loading: loadingCurrentUserFromContext,
  } = useVulcanCurrentUser();
  const shouldGetCurrentUserFromProps =
    typeof currentUserFromProps !== "undefined";
  const currentUser = shouldGetCurrentUserFromProps
    ? currentUserFromProps
    : currentUserFromContext;
  const loadingCurrentUser = shouldGetCurrentUserFromProps
    ? loadingCurrentUserFromProps
    : loadingCurrentUserFromContext;

  if (isEdit && loading) {
    return <Loading />;
  }
  return (
    <Form
      document={document}
      loading={!!(loading || loadingCurrentUser)}
      refetch={refetch}
      currentUser={currentUser}
      {...childProps}
      {...props}
    />
  );
};

/*
FormContainer.propTypes = {
  // main options
  documentId: PropTypes.string, // if a document is passed, this will be an edit form
  mutationFragment: PropTypes.object,
  mutationFragmentName: PropTypes.string,

  // graphQL
  // createFoo, deleteFoo, updateFoo
  // newMutation: PropTypes.func, // the new mutation
  // editMutation: PropTypes.func, // the edit mutation
  // removeMutation: PropTypes.func, // the remove mutation

  // form
  prefilledProps: PropTypes.object,
  layout: PropTypes.string,
  fields: PropTypes.arrayOf(PropTypes.string),
  hideFields: PropTypes.arrayOf(PropTypes.string),
  addFields: PropTypes.arrayOf(PropTypes.string),
  showRemove: PropTypes.bool,
  submitLabel: PropTypes.node,
  cancelLabel: PropTypes.node,
  revertLabel: PropTypes.node,
  repeatErrors: PropTypes.bool,
  warnUnsavedChanges: PropTypes.bool,
  formComponents: PropTypes.object,
  disabled: PropTypes.bool,
  itemProperties: PropTypes.object,
  successComponent: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),
  contextName: PropTypes.string,

  // callbacks
  ...callbackProps,

  currentUser: PropTypes.object,
  client: PropTypes.object,
};

FormContainer.defaultProps = {
  layout: "horizontal",
};
*/

/*
registerComponent({
  name: 'SmartForm',
  component: FormContainer,
  hocs: [withCurrentUser, withApollo, withRouter, withCollectionProps],
});
*/

export const SmartForm = FormContainer;

export default FormContainer;
